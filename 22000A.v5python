{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLF = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nLM = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nLR = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nRF = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nRM = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\nRR = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\ncontroller_1 = Controller(PRIMARY)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# how much the wheels need to turn to make the bot turn 180 degrees\nturn180 = 400\n# controller deadzone used to avoid the bot moving when you do not want it to\ndeadzone = 5\n# the speed that the bot will go when one of the axis is just past the deadzone\nminSpeed = 50\n# how far the wheels need to turn to move one inch\ndegToOneInch = 50\n\n# function that uses the turn180 constant to turn the degrees you want turn the bot to the distance to turn the drivetrain\ndef degToVex(deg):\n    return ((turn180 * deg) / 180)\n\ndef inchToDeg(inches):\n    return inches * degToOneInch\n\ndef ondriver_drivercontrol_0():\n    setStopCoast()\n\n    while True:\n\n        #|----- moving left drive -----|\n\n        # moving left forward\n        if controller_1.axis3.position() > deadzone:\n            setLeftSpeed(minSpeed + controller_1.axis3.position() / (100 / minSpeed))\n            driveLeftForward()\n\n        # moving left reverse\n        elif controller_1.axis3.position() < 0 - deadzone:\n            setLeftSpeed(minSpeed + (0 - controller_1.axis3.position()) / (100 / minSpeed))\n            driveLeftReverse()\n        \n        else:\n            stopLeft()\n\n        #|----- moving right drive -----|\n\n        # moving right forward\n        if controller_1.axis2.position() > deadzone:\n            setRightSpeed(minSpeed + controller_1.axis2.position() / (100 / minSpeed))\n            driveRightForward()\n\n        # moving right reverse\n        elif controller_1.axis2.position() < 0 - deadzone:\n            setRightSpeed(minSpeed + (0 - controller_1.axis2.position()) / (100 / minSpeed))\n            driveRightReverse()\n\n        else:\n            stopRight()\n\ndef onauton_autonomous_0():\n    setStopBrake()\n    setSpeed(100, 100)\n    move(10)\n    turnLeft(90)\n    move(-10)\n    turnRight(90)\n    move(5)\n \n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread( onauton_autonomous_0 )\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    driver_control_task_0 = Thread( ondriver_drivercontrol_0 )\n\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n    driver_control_task_0.stop()\n\n\n#|----- motor velo functions -----|\n\ndef setLeftSpeed(velo):\n    LF.set_velocity(velo)\n    LM.set_velocity(velo)\n    LR.set_velocity(velo)    \n\ndef setRightSpeed(velo):\n    RF.set_velocity(velo)\n    RM.set_velocity(velo)\n    RR.set_velocity(velo)\n\ndef setSpeed(leftVelo, rightVelo):\n    setLeftSpeed(leftVelo)\n    setRightSpeed(rightVelo)\n\n#|----- motor movement forward functions -----|\n\ndef moveLeft(dist, waiting = True):\n    LF.spin_for(FORWARD, dist, DEGREES, wait=False)\n    LM.spin_for(FORWARD, dist, DEGREES, wait=False)\n    LR.spin_for(FORWARD, dist, DEGREES, wait=waiting)\n\ndef moveRight(dist, waiting = True):\n    RF.spin_for(FORWARD, dist, DEGREES, wait=False)\n    RM.spin_for(FORWARD, dist, DEGREES, wait=False)\n    RR.spin_for(FORWARD, dist, DEGREES, wait=waiting)\n\ndef driveLeftForward():\n    LF.spin(FORWARD)\n    LM.spin(FORWARD)\n    LR.spin(FORWARD)\n\ndef driveLeftReverse():\n    LF.spin(REVERSE)\n    LM.spin(REVERSE)\n    LR.spin(REVERSE)\n\ndef driveRightForward():\n    LF.spin(FORWARD)\n    LM.spin(FORWARD)\n    LR.spin(FORWARD)\n\ndef driveRightReverse():\n    LF.spin(REVERSE)\n    LM.spin(REVERSE)\n    LR.spin(REVERSE)\n\n#|----- motor stopping functions -----|\n\ndef setStopCoast():\n    LF.set_stopping(COAST)\n    LM.set_stopping(COAST)\n    LR.set_stopping(COAST)\n    RF.set_stopping(COAST)\n    RM.set_stopping(COAST)\n    RR.set_stopping(COAST)\n\ndef setStopBrake():\n    LF.set_stopping(BRAKE)\n    LM.set_stopping(BRAKE)\n    LR.set_stopping(BRAKE)\n    RF.set_stopping(BRAKE)\n    RM.set_stopping(BRAKE)\n    RR.set_stopping(BRAKE)\n\ndef stopLeft():\n    LF.stop()\n    LM.stop()\n    LR.stop()\n\ndef stopRight():\n    RF.stop()\n    RM.stop()\n    RR.stop()\n\n#|----- motor movement turning functions -----|\n\ndef move(dist):\n    moveLeft(inchToDeg(dist))\n    moveRight(inchToDeg(dist))\n\ndef flipLeft():\n    moveLeft(0-turn180)\n    moveRight(turn180)\n\ndef flipRight():\n    moveLeft(turn180)\n    moveRight(0-turn180)\n\ndef turnLeft(deg):\n    moveLeft(0-degToVex(deg))\n    moveRight(degToVex(deg))\n\ndef turnRight(deg):\n    moveLeft(0-degToVex(deg))\n    moveRight(degToVex(deg))\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )","textLanguage":"python","rconfig":[{"port":[1],"name":"LF","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"LM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"LR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"RF","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"RM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"RR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}